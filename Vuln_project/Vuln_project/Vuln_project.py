import nmap
import sqlite3
import pandas as pd
import requests
from bs4 import BeautifulSoup
import tkinter as tk
from tkinter import ttk, messagebox
import threading
import time
from datetime import datetime

# List of important ports for faster scanning
important_ports = {
    'TCP': [22, 80, 443, 21, 25, 110, 143, 3389],  # Example TCP ports: SSH, HTTP, HTTPS, FTP, SMTP, POP3, IMAP, RDP
    'UDP': [53, 67, 68, 69, 123, 137, 138, 161, 162, 520, 514, 500, 1701, 4500, 1900, 1434, 1234, 33434]
}

# Database Setup
def setup_database():
    conn = sqlite3.connect('vulnerability_scan.db')
    c = conn.cursor()

    # Drop the scans table if it exists
    c.execute('DROP TABLE IF EXISTS scans')

    # Create the scans table with the correct schema
    c.execute('''
        CREATE TABLE scans (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT,
            host TEXT,
            ports TEXT,
            status TEXT,
            start_time TEXT,
            end_time TEXT
        )
    ''')

    # Create the scan_results table if it does not exist
    c.execute('''
        CREATE TABLE IF NOT EXISTS scan_results (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            scan_id INTEGER,
            target TEXT,
            host TEXT,
            port TEXT,
            state TEXT,
            service TEXT,
            vulnerability TEXT,
            FOREIGN KEY (scan_id) REFERENCES scans (id)
        )
    ''')
    conn.commit()
    conn.close()

# Perform Host and Web Scan
def initiate_scan(scan_id, target, ports):
    nm = nmap.PortScanner()
    tcp_ports = udp_ports = ''
    if ports == 'TCP':
        tcp_ports = ','.join(map(str, important_ports['TCP']))
    elif ports == 'UDP':
        udp_ports = ','.join(map(str, important_ports['UDP']))
    elif ports == 'TCP and UDP':
        tcp_ports = ','.join(map(str, important_ports['TCP']))
        udp_ports = ','.join(map(str, important_ports['UDP']))
    elif ports == 'TCP and UDP -p 1-1000':
        tcp_ports = '1-1000'
        udp_ports = '1-1000'
    elif ports == 'All Vulnerabilities':
        tcp_ports = '1-65535'
        udp_ports = '1-65535'

    arguments = f'-p T:{tcp_ports},U:{udp_ports} -T4 --script vuln'
    nm.scan(hosts=target, arguments=arguments)
    
    for host in nm.all_hosts():
        for proto in nm[host].all_protocols():
            lport = nm[host][proto].keys()
            for port in lport:
                state = nm[host][proto][port]['state']
                service = nm[host][proto][port]['name']
                vulnerability = ', '.join(nm[host][proto][port].get('script', {}).get('vulns', []))

                # Insert results into the database
                conn = sqlite3.connect('vulnerability_scan.db')
                c = conn.cursor()
                c.execute("INSERT INTO scan_results (scan_id, target, host, port, state, service, vulnerability) VALUES (?, ?, ?, ?, ?, ?, ?)",
                          (scan_id, target, host, port, state, service, vulnerability))
                conn.commit()
                conn.close()

        # Web Vulnerability Scanning
        if "http://" in target or "https://" in target:
            try:
                response = requests.get(target, timeout=5)
                soup = BeautifulSoup(response.text, 'html.parser')

                vulnerabilities = []

                # Check for common vulnerabilities (simplified examples)
                if soup.find('input'):
                    vulnerabilities.append('Form found: Potential for XSS or SQL Injection')

                if 'X-Content-Type-Options' not in response.headers:
                    vulnerabilities.append('Missing X-Content-Type-Options header: Potential for MIME Sniffing attacks')

                if 'X-Frame-Options' not in response.headers:
                    vulnerabilities.append('Missing X-Frame-Options header: Potential for Clickjacking attacks')

                # Update the database with vulnerabilities
                conn = sqlite3.connect('vulnerability_scan.db')
                c = conn.cursor()
                for proto in nm[host].all_protocols():
                    lport = nm[host][proto].keys()
                    for port in lport:
                        c.execute("UPDATE scan_results SET vulnerability = ? WHERE scan_id = ? AND target = ? AND host = ? AND port = ?",
                                  (', '.join(vulnerabilities), scan_id, target, host, port))
                        conn.commit()
                conn.close()
            except Exception as e:
                print(f"Failed to scan {target}: {e}")

    # Mark scan as complete with end time
    end_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    conn = sqlite3.connect('vulnerability_scan.db')
    c = conn.cursor()
    c.execute("UPDATE scans SET status = ?, end_time = ? WHERE id = ?", ("Completed", end_time, scan_id))
    conn.commit()
    conn.close()

# Schedule a scan at specific intervals
def schedule_scan(scan_id, target, ports, interval):
    def run_scheduled_scan():
        while True:
            start_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            conn = sqlite3.connect('vulnerability_scan.db')
            c = conn.cursor()
            c.execute("UPDATE scans SET start_time = ? WHERE id = ?", (start_time, scan_id))
            conn.commit()
            conn.close()

            initiate_scan(scan_id, target, ports)
            time.sleep(interval)

    threading.Thread(target=run_scheduled_scan).start()

# GUI Application
def initiate_gui():
    def add_scan():
        add_scan_window = tk.Toplevel(root)
        add_scan_window.title("Add Scan")
        add_scan_window.geometry("300x200")

        tk.Label(add_scan_window, text="Name:").pack(pady=5)
        name_entry = tk.Entry(add_scan_window)
        name_entry.pack(pady=5)

        tk.Label(add_scan_window, text="Host:").pack(pady=5)
        host_entry = tk.Entry(add_scan_window)
        host_entry.pack(pady=5)

        tk.Label(add_scan_window, text="Port List:").pack(pady=5)
        port_var = tk.StringVar(value='TCP')
        ttk.Combobox(add_scan_window, textvariable=port_var, values=["TCP", "UDP", "TCP and UDP", "TCP and UDP -p 1-1000", "All Vulnerabilities"]).pack(pady=5)

        def save_scan():
            name = name_entry.get()
            host = host_entry.get()
            ports = port_var.get()
            if not name or not host:
                messagebox.showerror("Error", "Name and Host are required!")
                return

            # Insert scan into the database
            conn = sqlite3.connect('vulnerability_scan.db')
            c = conn.cursor()
            c.execute("INSERT INTO scans (name, host, ports, status, start_time, end_time) VALUES (?, ?, ?, ?, ?, ?)",
                      (name, host, ports, "Pending", None, None))
            conn.commit()
            scan_id = c.lastrowid
            conn.close()

            # Start the scan in a new thread
            threading.Thread(target=start_scan, args=(scan_id, name, host, ports)).start()

            add_scan_window.destroy()
            update_scan_table()

        tk.Button(add_scan_window, text="Save Scan", command=save_scan).pack(pady=10)

    def add_schedule_scan():
        schedule_scan_window = tk.Toplevel(root)
        schedule_scan_window.title("Schedule Scan")
        schedule_scan_window.geometry("300x300")

        tk.Label(schedule_scan_window, text="Name:").pack(pady=5)
        name_entry = tk.Entry(schedule_scan_window)
        name_entry.pack(pady=5)

        tk.Label(schedule_scan_window, text="Host:").pack(pady=5)
        host_entry = tk.Entry(schedule_scan_window)
        host_entry.pack(pady=5)

        tk.Label(schedule_scan_window, text="Port List:").pack(pady=5)
        port_var = tk.StringVar(value='TCP')
        ttk.Combobox(schedule_scan_window, textvariable=port_var, values=["TCP", "UDP", "TCP and UDP", "TCP and UDP -p 1-1000", "All Vulnerabilities"]).pack(pady=5)

        tk.Label(schedule_scan_window, text="Schedule Time:").pack(pady=5)
        schedule_var = tk.StringVar(value='1 minute')
        ttk.Combobox(schedule_scan_window, textvariable=schedule_var, values=["1 minute", "5 minutes", "30 minutes", "1 hour", "1 day", "1 week", "1 month"]).pack(pady=5)

        def save_scheduled_scan():
            name = name_entry.get()
            host = host_entry.get()
            ports = port_var.get()
            schedule_time = schedule_var.get()
            if not name or not host:
                messagebox.showerror("Error", "Name and Host are required!")
                return

            # Insert scheduled scan into the database
            conn = sqlite3.connect('vulnerability_scan.db')
            c = conn.cursor()
            c.execute("INSERT INTO scans (name, host, ports, status, start_time, end_time) VALUES (?, ?, ?, ?, ?, ?)",
                      (name, host, ports, "Scheduled", None, None))
            conn.commit()
            scan_id = c.lastrowid
            conn.close()

            # Schedule the scan
            time_mapping = {
                "1 minute": 60,
                "5 minutes": 300,
                "30 minutes": 1800,
                "1 hour": 3600,
                "1 day": 86400,
                "1 week": 604800,
                "1 month": 2592000
            }
            interval = time_mapping.get(schedule_time, 60)

            threading.Thread(target=schedule_scan, args=(scan_id, host, ports, interval)).start()

            schedule_scan_window.destroy()
            update_scan_table()

        tk.Button(schedule_scan_window, text="Save Scheduled Scan", command=save_scheduled_scan).pack(pady=10)

    def start_scan(scan_id, name, host, ports):
        start_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        conn = sqlite3.connect('vulnerability_scan.db')
        c = conn.cursor()
        c.execute("UPDATE scans SET start_time = ? WHERE id = ?", (start_time, scan_id))
        conn.commit()
        conn.close()
        
        initiate_scan(scan_id, host, ports)
        update_scan_table()

    def on_scan_select(event):
        selected_items = scan_table.selection()
        if not selected_items:
            messagebox.showwarning("Warning", "No scan selected!")
            return

        item = selected_items[0]
        scan_id = scan_table.item(item, "values")[0]
        view_report(scan_id)

    def view_report(scan_id):
        def refresh_report():
            try:
                # Fetch scan details including start and end times
                scan_details = pd.read_sql_query(f"SELECT * FROM scans WHERE id = {scan_id}", conn).iloc[0]
                df = pd.read_sql_query(f"SELECT * FROM scan_results WHERE scan_id = {scan_id}", conn)
            except pd.errors.DatabaseError as e:
                messagebox.showerror("Database Error", f"An error occurred while fetching the report: {e}")
                return

            text.delete("1.0", tk.END)
            text.insert(tk.END, f"Scan Report for {scan_details['name']} (ID: {scan_details['id']})\n")
            text.insert(tk.END, f"Host: {scan_details['host']}\n")
            text.insert(tk.END, f"Ports: {scan_details['ports']}\n")
            text.insert(tk.END, f"Status: {scan_details['status']}\n")
            text.insert(tk.END, f"Start Time: {scan_details['start_time']}\n")
            text.insert(tk.END, f"End Time: {scan_details['end_time']}\n")
            text.insert(tk.END, "\n")
            text.insert(tk.END, df.to_string(index=False))
            text.pack(expand=1, fill='both')

            report_window.after(10000, refresh_report)  # Refresh every 10 seconds

        report_window = tk.Toplevel(root)
        report_window.title("Scan Report")
        report_window.geometry("800x600")

        conn = sqlite3.connect('vulnerability_scan.db')
        text = tk.Text(report_window, wrap='word')
        text.pack(expand=1, fill='both')

        refresh_report()

    def remove_scan():
        selected_items = scan_table.selection()
        if not selected_items:
            messagebox.showwarning("Warning", "No scan selected!")
            return

        for item in selected_items:
            scan_id = scan_table.item(item, "values")[0]
            conn = sqlite3.connect('vulnerability_scan.db')
            c = conn.cursor()
            c.execute("DELETE FROM scans WHERE id = ?", (scan_id,))
            c.execute("DELETE FROM scan_results WHERE scan_id = ?", (scan_id,))
            conn.commit()
            conn.close()
            scan_table.delete(item)

    def update_scan_table():
        for item in scan_table.get_children():
            scan_table.delete(item)

        conn = sqlite3.connect('vulnerability_scan.db')
        c = conn.cursor()
        c.execute("SELECT * FROM scans")
        for row in c.fetchall():
            scan_table.insert('', 'end', values=row)
        conn.close()

    root = tk.Tk()
    root.title("Vulnerability Scanner")
    root.geometry("1000x600")

    left_frame = tk.Frame(root, width=200, height=600, bg='grey')
    left_frame.pack(side='left', fill='y')

    right_frame = tk.Frame(root, width=800, height=600)
    right_frame.pack(side='right', fill='both', expand=True)

    # Left frame components
    tk.Label(left_frame, text="Scan Options", bg='grey', fg='white', font=("Helvetica", 16)).pack(pady=10)
    tk.Button(left_frame, text="Add Scan", command=add_scan, width=20).pack(pady=10)
    tk.Button(left_frame, text="Schedule Scan", command=add_schedule_scan, width=20).pack(pady=10)
    tk.Button(left_frame, text="Remove Scan", command=remove_scan, width=20).pack(pady=10)

    # Right frame components
    tk.Label(right_frame, text="Scan Details", font=("Helvetica", 16)).pack(pady=10)

    scan_table = ttk.Treeview(right_frame, columns=("ID", "Name", "Host", "Ports", "Status", "Start Time", "End Time"), show='headings')
    scan_table.heading("ID", text="ID")
    scan_table.heading("Name", text="Name")
    scan_table.heading("Host", text="Host")
    scan_table.heading("Ports", text="Ports")
    scan_table.heading("Status", text="Status")
    scan_table.heading("Start Time", text="Start Time")
    scan_table.heading("End Time", text="End Time")
    scan_table.pack(expand=1, fill='both')

    scan_table.bind('<Double-1>', on_scan_select)

    update_scan_table()
    root.mainloop()

# Main Function
def main():
    setup_database()
    initiate_gui()

if __name__ == "__main__":
    main()
